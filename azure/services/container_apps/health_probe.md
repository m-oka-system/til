# Azure Container Apps の正常性プローブについて

Azure Container Apps の正常性プローブは、Container Apps の実行環境がコンテナアプリの状態を定期的に確認するための仕組みです。これにより、アプリケーションが正常に動作しているかを監視し、問題が発生した場合に自動的に対処することができます。

プローブの設定は、TCP または HTTP(S) のいずれかを使用して行うことができます。

## プローブの種類

Container Apps では、以下の種類のプローブがサポートされています。

| プローブの種類               | 説明                                                                                                                                                                                       |
| :--------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Startup (スタートアップ)** | アプリケーションが正常に起動したかどうかを確認します。この確認は、Liveness プローブとは別に行われ、アプリケーションの初期起動フェーズで実行されます。                                      |
| **Liveness (ライブネス)**    | アプリケーションが引き続き実行中で、応答可能な状態であるかどうかを確認します。「生きているか」をチェックするイメージです。このプローブが失敗すると、コンテナが再起動されることがあります。 |
| **Readiness (レディネス)**   | アプリケーションのレプリカ（コピー）が、新しいリクエストを受け付ける準備ができているかどうかを確認します。準備ができていないレプリカには、新しいリクエストが送信されなくなります。         |

## 各プローブの実行タイミング

各プローブが Docker コンテナのライフサイクルにおいて、どのタイミングで実行されるかを説明します。

1.  **コンテナ起動シーケンスの開始**:
    - コンテナの起動プロセスが開始されます。
2.  **Startup プローブ**:
    - **タイミング**: コンテナの起動処理が開始された直後から、アプリケーションが完全に起動するまでの間。
    - **目的**: アプリケーションが起動に時間がかかる場合でも、正常に起動処理を完了したことを確認します。
    - **動作**: このプローブが成功するまで、Liveness および Readiness プローブは開始されません。指定回数失敗すると、コンテナは再起動されることがあります。
3.  **Liveness プローブ**:
    - **タイミング**: Startup プローブが成功した後、コンテナが実行されている間、定期的に実行されます。
    - **目的**: アプリケーションが応答不能な状態（デッドロックなど）に陥っていないかを確認し、「生存」を確認します。
    - **動作**: このプローブが失敗すると、コンテナは問題があると見なされ、再起動されます。
4.  **Readiness プローブ**:
    - **タイミング**: Startup プローブが成功した後、コンテナが実行されている間、定期的に実行されます。
    - **目的**: アプリケーションが新しいリクエストを受け付ける準備ができているかを確認します。
    - **動作**: このプローブが成功するまで、コンテナのレプリカはサービスディスカバリ（リクエストの振り分け先リスト）に含まれず、トラフィックを受信しません。プローブが失敗している間は、一時的にトラフィックの対象から外れます。

## Liveness プローブと Readiness プローブの主な違い

Liveness プローブと Readiness プローブは、どちらもコンテナの健全性を確認しますが、その目的とプローブ失敗時の挙動が異なります。

- **Liveness プローブ (生存確認)**

  - **確認すること**: 「コンテナはまだ生きているか？（応答不能になっていないか？）」
  - **失敗した場合**: コンテナが**再起動**されます。
    - **理由**: アプリケーションがデッドロックしたり、応答しなくなったりした場合に、コンテナを再起動することで問題を自動的に解決しようとします。

- **Readiness プローブ (準備完了確認)**
  - **確認すること**: 「コンテナは新しいリクエストを受け付ける準備ができているか？」
  - **失敗した場合**: コンテナは再起動されず、そのコンテナへの**新しいリクエストの送信が一時停止**されます。
    - **理由**: アプリケーションが起動していても、一時的に新しいリクエストを処理できない状態（例: 外部サービスへの接続待ち、初期データの読み込み中）である可能性があるため、準備ができるまでリクエストの受付を停止します。

**使い分けのポイント**:

- アプリケーションが応答しなくなり、再起動によって回復する可能性がある場合は、**Liveness プローブ** を設定します。
- アプリケーションが起動後、リクエストを受け付けるまでに時間がかかる処理（依存サービスの確認、データロードなど）がある場合や、一時的にリクエストを処理できない状態になり得る場合は、**Readiness プローブ** を設定します。

多くの場合、これらのプローブは両方設定することが推奨されます。

## プローブ設定のベストプラクティス

各プローブの目的に応じて、以下のパラメータを適切に設定することが重要です。

### 一般的な設定パラメータと推奨

- **転送 (Transport)**: `HTTP`/`HTTPS` (推奨) または `TCP`。
  - **推奨理由**: HTTP(S)はアプリケーションレベルのヘルスチェックに適しています。TCP はポート疎通のみ確認します。
- **パス (Path)** (HTTP/HTTPS 時): プローブ用エンドポイント (例: `/healthz`, `/ready`)。
  - **Liveness**: `/live` など、軽量な応答確認用。
  - **Readiness**: `/ready` など、依存関係も含めた総合的な準備完了確認用。
- **ポート (Port)**: アプリケーションがリッスンしているポート。
- **初期遅延期間 (秒) (Initial Delay Seconds)**: 最初のプローブ開始までの待機時間。
  - **Startup**: アプリ起動に必要な時間 +α。
  - **Liveness/Readiness**: アプリが応答可能/準備完了になるまでの時間。
- **期間 (秒) (Period Seconds)**: プローブ実行間隔。
  - 一般的に 5 秒～ 30 秒程度。問題検知の速さと負荷のバランスを考慮。
- **タイムアウト (秒) (Timeout Seconds)**: プローブの応答待ち時間。
  - 通常応答時間 +α (例: 1 秒～ 5 秒)。短すぎると誤検知の原因に。
- **成功のしきい値 (Success Threshold)**: 通常 `1`。
- **失敗のしきい値 (Failure Threshold)**: 連続失敗回数。
  - `2`～`3` を推奨。`1` だと一時的な問題で意図しない再起動やトラフィック停止が起きやすい。
- **HTTP ヘッダー (HTTP Headers)**: 必要に応じてカスタムヘッダーを設定。

### 各プローブごとの設定ポイント

1.  **Startup プローブ**:

    - **目的**: アプリケーションの起動完了を確認。
    - **設定**: `initialDelaySeconds` はアプリ起動時間に合わせ、`failureThreshold` × `periodSeconds` が想定起動時間をカバーするように調整。

2.  **Liveness プローブ**:

    - **目的**: アプリケーションの生存確認。失敗でコンテナ再起動。
    - **設定**: エンドポイントは軽量に。`failureThreshold` は Readiness プローブよりも高く設定し（例えば Readiness が 3 なら Liveness は 5-10 など）、不必要な再起動を避けることが一般的なパターンです。これにより、Readiness が失敗しても即座に再起動されず、一定期間の猶予が生まれます。

3.  **Readiness プローブ**:
    - **目的**: アプリケーションのリクエスト受付準備完了確認。失敗でトラフィック停止。
    - **設定**:
      - 軽量なエンドポイントを Liveness と共有し、`failureThreshold` を Liveness より低く設定するパターンがあります。
      - バックエンドサービス（DB、外部 API など）との依存関係を含めた詳細なチェックを行う場合は、Liveness プローブとは別の専用エンドポイント (`/ready` など) を用意し、そこで総合的な準備状況を確認することが推奨されます。この場合、Liveness プローブは引き続き軽量なエンドポイント (`/live` など) でコンテナ自体の生存を確認します。

### 運用上のヒントとエンドポイント設計

- **専用エンドポイント**: `/healthz` や `/ready` のような専用のヘルスチェックエンドポイントを実装しましょう。
- **軽量なプローブ**: プローブ処理自体がアプリに高負荷をかけないようにします。
- **監視と調整**: ログやメトリクスでプローブの状態を監視し、設定を継続的に見直します。
- **段階的な調整**: 最初は緩めの設定から始め、安定性を確認しながら徐々に厳密な設定に調整します。
- **Liveness/Readiness エンドポイントの共通化と分離**:
  - **共通化パターン**: Liveness と Readiness で同じ軽量エンドポイントを使用し、Liveness の `failureThreshold` を Readiness より高く設定することで、コンテナが即座に再起動されるのを防ぎ、猶予期間を設けることができます。これは、アプリケーションが一時的にリクエストを処理できなくなることはあっても、完全に停止しているわけではない場合に有効です。
  - **分離パターン**: Readiness プローブでデータベース接続や外部サービス連携など、より複雑なチェックを行う場合は、Liveness プローブとは異なるエンドポイントを使用する方が明確です。Liveness はコンテナの基本的な応答性を、Readiness はサービスの提供可否をそれぞれ独立して確認できます。

## livenss と readiness を分けるべき代表的な条件

### 1. **アプリの起動に時間がかかる場合**

#### ✔ readiness を分けるべき理由：

アプリ起動直後、DB や外部 API への接続が完了する前にトラフィックを受けると失敗する。

- **readiness**: 外部サービスが使えるようになるまで `200 OK` を返さない
- **liveness**: アプリ自体が起動して HTTP 応答できるかだけを確認

📝 _例:_ 初期化処理中は readiness が失敗 → トラフィックを受けない

---

### 2. **アプリがフリーズすることがある（メモリリークや無限ループなど）**

#### ✔ liveness を分けるべき理由：

アプリがハングアップしても readiness では検知できない（エンドポイントは動いてるように見える）。

- **liveness**: 短時間での応答を求め、失敗時は再起動で復旧を試みる
- **readiness**: アプリが処理可能かの判定に集中

📝 _例:_ 定期的に `/liveness` にアクセスして、タイムアウトすれば自動再起動

---

### 3. **外部サービスが一時的に不安定になる場合**

#### ✔ readiness の分離でユーザー体験を守る：

- DB や API が一時停止 → readiness を NG にして、アプリはリクエストを受けず待機
- liveness はあくまで「プロセスが生きてるか」だけを見る（アプリ再起動しない）

📝 _例:_ 「DB に接続できるか」を readiness で判定、DB が止まっても再起動は避ける

---

### 4. **HTTP サーバーは応答するが、アプリの内部ロジックが壊れている場合**

#### ✔ 違うエンドポイントを使うと安全：

- `/liveness`：単に 200 返す最小限のヘルスチェック
- `/readiness`：依存関係のチェックを含めた実行可能性確認

📝 _例:_ メモリ過多やスレッドスタックなどで一見動いてるがレスポンス異常なケースに備える

---

## 実際の分け方例

| 項目           | readiness                     | liveness                          |
| -------------- | ----------------------------- | --------------------------------- |
| エンドポイント | `/ready`                      | `/live`                           |
| チェック内容   | DB 接続確認、キューの準備など | ポート応答確認、HTTP 200 だけ返す |
| 初期遅延       | 起動に応じて調整（例: 10 秒） | 通常 0 秒（即チェック）           |
| タイムアウト   | 2 秒程度                      | 1 秒未満で短く                    |

---

## 補足：プローブ実装のイメージ（Python Flask）

```python
@app.route('/ready')
def readiness():
    if check_db_connection() and check_cache_ready():
        return "Ready", 200
    return "Not Ready", 500

@app.route('/live')
def liveness():
    return "Alive", 200
```

# 参考 URL

https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
https://learn.microsoft.com/ja-jp/azure/container-apps/health-probes?tabs=arm-template
